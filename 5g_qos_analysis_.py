# -*- coding: utf-8 -*-
"""5G-QoS-Analysis .ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1UHblpGbbxv0k_EwteddilBaP0dfdwCbf

#Import Libraries
"""

import pandas as pd
import numpy as np
import warnings
import matplotlib.pyplot as plt
import seaborn as sns
import plotly.express as px
warnings.filterwarnings('ignore')

from google.colab import drive
drive.mount('/content/drive')

"""#Load the Dataset"""

data = pd.read_csv('/content/drive/MyDrive/dataset/Quality of Service 5G.csv')

data.columns

"""#Display the dataset"""

data.head()

"""#summary"""

data.describe().T

data.info()

data.isnull().sum()

data.size

data.shape

"""#Unique values"""

data['User_ID'].nunique()

data['Application_Type'].unique()

data['Application_Type'].nunique()

data['Signal_Strength'].unique()

data['Signal_Strength'].nunique()

data['Latency'].unique()

data['Latency'].nunique()

data['Resource_Allocation'].unique()

"""#Regex Cleaning"""

data['Signal_Strength'] = data['Signal_Strength'].str.extract('(\d+)').astype(int)
data['Latency'] = data['Latency'].str.extract('(\d+)').astype(int)
data['Resource_Allocation'] = data['Resource_Allocation'].str.extract('(\d+)').astype(int)

data.head()

data[['Size','Unit']] = data.Required_Bandwidth.str.split(' ', expand=True)

data['Size'] = data.Size.astype(float)

data.Unit.replace({'Mbps':1024, 'Kbps':1}, inplace=True)

data.head()

data['Required_Bandwidth_Size_in_KB'] = data.Size * data.Unit

data.head(1)

data.drop(columns='Size',inplace=True)
data.drop(columns='Unit',inplace=True)

data.head(1)

"""#Converting Allocated_Bandwidth Unit from Mbps to Kbps"""

data[['Size1','Unit1']] = data.Allocated_Bandwidth.str.split(' ', expand=True)

data['Size1'] = data.Size1.astype(float)

data.Unit1.replace({'Mbps':1024, 'Kbps':1}, inplace=True)

data['Allocated_Bandwidth_Size_in_KB'] = data.Size1 * data.Unit1

data.head(1)

data.drop(columns='Size1',inplace=True)
data.drop(columns='Unit1',inplace=True)

data.head(1)

data.drop(columns='Allocated_Bandwidth',inplace=True)
data.drop(columns='Required_Bandwidth',inplace=True)

data.head(1)

data.rename(columns = {'Required_Bandwidth_Size_in_KB':'Required_Bandwidth'},inplace=True)

data.rename(columns = {'Allocated_Bandwidth_Size_in_KB':'Allocated_Bandwidth'},inplace=True)

data.head(1)

"""#Online Gaming with least avg bandwidth requirement"""

new_data_Online_Gaming = data[data['Application_Type']=='Online_Gaming']

sorted_Online_Gaming = new_data_Online_Gaming.sort_values(by='Required_Bandwidth')

sorted_Online_Gaming.tail(1)

data['Timestamp'].nunique()

"""#User with high signal strength"""

data.Signal_Strength.max()

data.query("Signal_Strength == 123")

"""#User with high Required_Bandwidth"""

data.Required_Bandwidth.max()

data.query("Required_Bandwidth == 14848")

"""#User with high Allocated_Bandwidth"""

data.Allocated_Bandwidth.max()

data.query("Allocated_Bandwidth == 16179.2")

"""#User with high Latency"""

data.Latency.max()

data.query("Latency == 110")

"""#Average of signal strength on diffrent application"""

app_signsl_strength = data.groupby(['Application_Type'])['Signal_Strength'].mean()

"""#maximum average of signal strength on diffrent application"""

app_signsl_strength.nlargest()

"""#Minimum average of signal strength on diffrent application"""

app_signsl_strength.nsmallest()

"""#Average of latency on diffrent application"""

app_Latency = data.groupby(['Application_Type'])['Latency'].mean()

"""#maximum average of latency on diffrent application"""

app_Latency.nlargest()

"""#minimum average of latency on diffrent application"""

app_Latency.nsmallest()

data.groupby(['Application_Type'])['Latency'].mean()

"""#Average of resource_Allocation on diffrent application"""

app_Resource_Allocation = data.groupby(['Application_Type'])['Resource_Allocation'].mean()

"""#maximum average of latency on diffrent application"""

app_Resource_Allocation.nlargest()

"""#minimum average of latency on diffrent application"""

app_Resource_Allocation.nsmallest()

"""#Average of resource_Allocation on diffrent Timestamp"""

timestamp_Resource = data.groupby(['Timestamp'])['Resource_Allocation'].mean()

timestamp_Resource.nlargest()

timestamp_Resource.nsmallest()

timestamp_Latency = data.groupby(['Timestamp'])['Latency'].mean()

timestamp_Latency

"""#VISUALISATION

Visualize Latency by Application Type
"""

plt.figure(figsize=(12, 6))
sns.boxplot(x='Application_Type', y='Latency', data=data)
plt.title('Latency by Application Type')
plt.xticks(rotation=45)
plt.show()

"""#Visualize Signal_Strength by Application_Type"""

plt.figure(figsize=(12, 6))
sns.boxplot(x='Application_Type', y='Signal_Strength', data=data)
plt.title('Signal Strength by Application Type')
plt.xticks(rotation=45)
plt.show()

data_sorted = data.sort_values(by='Required_Bandwidth')

plt.figure(figsize=(16, 6))
sns.barplot(data=data_sorted, x= 'Application_Type', y = 'Required_Bandwidth')
plt.show()

"""#Find count of values in Resource_Allocation"""

sns.countplot(x=data['Resource_Allocation'])

plt.figure(figsize=(10, 6))
sns.countplot(data=data, x='Application_Type')
plt.title('Distribution of Application Types')
plt.xticks(rotation=45)
plt.xlabel('Application Type')
plt.ylabel('Count')
plt.show()

"""#Distribution of Resource Allocation"""

plt.figure(figsize=(10, 6))
sns.histplot(data=data, x='Resource_Allocation', bins=10 ,kde=True)
plt.title('Distribution of Resource Allocation')
plt.xlabel('Resource Allocation (%)')
plt.ylabel('Count')
plt.show()

plt.figure(figsize=(6,6))
plt.title('Resource_Allocation')
plt.xlabel('Range')
plt.ylabel('Count')
plt.xticks(rotation = 45)
plt.yticks(rotation = 45)
sns.histplot(data=data, x='Resource_Allocation')
plt.show()

app_name  =data.Application_Type.value_counts().index
lat_val = data.Latency.value_counts().values
plt.pie(lat_val[:7],labels = app_name[:7],autopct='%1.f%%');

data.head(1)

data.info()

data.Timestamp.unique()

ts1=data.query("Timestamp =='9/3/2023 10:00'")
ts1.head()

ts1pie = ts1.groupby(['Application_Type'])['Application_Type'].count().reset_index(name='type_count')
ts1pie

ts1pie.type_count

"""distribution of Application type chosen random timestamp"""

plt.figure(figsize=(12,8))
plt.pie(ts1pie.type_count.values,labels = ts1pie.Application_Type.values,autopct='%1.2f%%');

"""Distribution of Signal StrengthÂ¶"""

plt.figure(figsize=(10, 12))
sns.histplot(data=data, x='Signal_Strength', bins=20, kde=True)
plt.title('Distribution of Signal Strength')
plt.xlabel('Signal Strength')
plt.ylabel('Frequency')
plt.show()

application_counts = data['Application_Type'].value_counts()
application_counts

"""Most Commonly Used Application Types"""

plt.figure(figsize=(10, 6))
sns.barplot(x=application_counts.index, y=application_counts.values, palette="viridis")
plt.title('Most Commonly Used Application Types')
plt.xlabel('Application Type')
plt.ylabel('Count')
plt.xticks(rotation=90)
plt.show()

"""Plot a scatter plot to explore the correlation"""

plt.figure(figsize=(8, 6))
sns.scatterplot(data=data, x='Signal_Strength', y='Allocated_Bandwidth',)
plt.title('Correlation Between Signal Strength and Allocated Bandwidth')
plt.xlabel('Signal Strength')
plt.ylabel('Allocated Bandwidth')
plt.grid(True)
plt.show()

correlation_coefficient = data['Signal_Strength'].corr(data['Allocated_Bandwidth'])
print(f"Correlation Coefficient: {correlation_coefficient}")

"""Plot a histogram to visualize the distribution of resource allocation"""

plt.figure(figsize=(8, 6))
sns.histplot(data=data, x='Resource_Allocation', bins=20, kde=True)
plt.title('Distribution of Resource Allocation Among Users')
plt.xlabel('Resource Allocation')
plt.ylabel('Frequency')
plt.show()

"""Plot a scatter plot to explore the relationship between allocated bandwidth and required bandwidth"""

plt.figure(figsize=(8, 6))
sns.scatterplot(data=data, x='Required_Bandwidth', y='Allocated_Bandwidth')
plt.title('Relationship Between Allocated Bandwidth and Required Bandwidth')
plt.xlabel('Required Bandwidth')
plt.ylabel('Allocated Bandwidth')
plt.grid(True)
plt.show()

"""#Model Training

"""

from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler, LabelEncoder

# Encode categorical variables
le = LabelEncoder()
data['Application_Type'] = le.fit_transform(data['Application_Type'])

# Split the data into features and target
X = data.drop(columns=['User_ID', 'Timestamp', 'Allocated_Bandwidth'])
y = data['Allocated_Bandwidth']

# Train-test split
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Standardize the numerical features
scaler = StandardScaler()
X_train[['Signal_Strength', 'Latency', 'Resource_Allocation', 'Required_Bandwidth']] = scaler.fit_transform(X_train[['Signal_Strength', 'Latency', 'Resource_Allocation', 'Required_Bandwidth']])
X_test[['Signal_Strength', 'Latency', 'Resource_Allocation', 'Required_Bandwidth']] = scaler.transform(X_test[['Signal_Strength', 'Latency', 'Resource_Allocation', 'Required_Bandwidth']])

from sklearn.linear_model import LinearRegression
from sklearn.ensemble import RandomForestRegressor
from sklearn.metrics import mean_squared_error, r2_score

# Initialize models
lr = LinearRegression()
rf = RandomForestRegressor(random_state=42)

# Train models
lr.fit(X_train, y_train)
rf.fit(X_train, y_train)

# Predictions
y_pred_lr = lr.predict(X_test)
y_pred_rf = rf.predict(X_test)

# Evaluate models
mse_lr = mean_squared_error(y_test, y_pred_lr)
r2_lr = r2_score(y_test, y_pred_lr)

mse_rf = mean_squared_error(y_test, y_pred_rf)
r2_rf = r2_score(y_test, y_pred_rf)

print(f"Linear Regression MSE: {mse_lr}, R2: {r2_lr}")
print(f"Random Forest MSE: {mse_rf}, R2: {r2_rf}")

import matplotlib.pyplot as plt

# Scatter plot for Linear Regression
plt.figure(figsize=(10, 6))
plt.scatter(y_test, y_pred_lr, color='blue', label='Linear Regression')
plt.xlabel('Actual Allocated Bandwidth')
plt.ylabel('Predicted Allocated Bandwidth')
plt.title('Linear Regression: Actual vs Predicted')
plt.legend()
plt.show()

# Scatter plot for Random Forest
plt.figure(figsize=(10, 6))
plt.scatter(y_test, y_pred_rf, color='red', label='Random Forest')
plt.xlabel('Actual Allocated Bandwidth')
plt.ylabel('Predicted Allocated Bandwidth')
plt.title('Random Forest: Actual vs Predicted')
plt.legend()
plt.show()